# 통합테스트(IntegrationTest) 쉬운 보고서 – Testcontainers 중심 해설

## 이 문서에서 다루는 것
- Testcontainers가 무엇이고, 왜 쓰는가
- 어떻게(단계별) 사용하는가, 안 쓸 때와 무엇이 다른가
- 스프링 테스트 어노테이션(`@SpringBootTest`, `@TestPropertySource`, `@Import` 등)
- 라이프사이클 훅(`@BeforeEach`, `@AfterEach`)을 왜 쓰는가
- 실제 통합 테스트 코드의 핵심 문법과 우리가 개선한 점

---

## Testcontainers란 무엇이고, 왜 쓸까?
- 한 줄 요약: “테스트가 사용할 실서비스급 의존성(DB, MQ 등)을 도커 컨테이너로 자동 띄워주는 테스트 도우미.”
- 왜 필요?
  - 로컬/CI 어디서나 동일한 DB(MariaDB/MySQL 등) 환경을 재현해 “환경차이 버그”를 줄입니다.
  - H2 같은 인메모리 DB는 실제 MySQL과 동작/SQL 방언이 달라 통합 시점에 깨질 수 있습니다.
  - 컨테이너를 테스트 시작/종료와 함께 자동 수명주기로 관리하니, 복잡한 사전 설치 없이 바로 실행 가능합니다.

### 쓰는 것 vs 안 쓰는 것
- 쓰지 않는 경우
  - H2 같은 임시 DB로 대충 통과 → 실제 운영 DB에서 실패(방언/제약/트랜잭션 차이)할 위험.
  - 팀원/CI 환경마다 설치 버전이 달라 “내 PC에선 되는데?” 문제가 발생.
- 쓰는 경우
  - 테스트가 도커를 통해 “같은 버전”의 MySQL을 항상 사용.
  - 데이터 제약/트랜잭션/인덱스 전략 등 운영 환경과 거의 동일하게 검증.

### 단계별 사용 프로세스
1) 의존성 추가
   - Gradle에 Testcontainers, JDBC 드라이버, 해당 DB 모듈(MySQL) 의존성을 추가.
2) 공용 설정 클래스 작성
   - 예: `TestContainersConfiguration`
   - 테스트 전체에서 재사용할 컨테이너(MySQL)를 정의하고, 스프링이 해당 컨테이너에 연결하도록 DataSource/URL을 노출.
3) 테스트 클래스에서 설정 주입
   - `@Import(TestContainersConfiguration.class)`로 컨테이너 설정을 불러옴.
   - `@TestPropertySource`로 테스트용 프로퍼티(예: `application-test.properties`)를 활성화.
4) 컨테이너 수명주기
   - 테스트 시작 시 도커 컨테이너가 자동으로 기동되고, 종료 시 정리됩니다(리소스 리이핑).
5) 실제 사용
   - 통합 테스트는 평소처럼 JPA 리포지토리/서비스를 호출하면 되고, 내부적으로는 컨테이너 DB가 쓰입니다.

---

## 스프링 테스트 어노테이션 해설
- `@SpringBootTest`
  - 스프링 애플리케이션 컨텍스트를 통째로 띄워 “실제 빈 구성” 상태에서 테스트합니다.
  - 레이어 간 협업(서비스↔리포지토리↔DB)을 통합적으로 검증하기 위해 사용.
- `@Import(TestContainersConfiguration.class)`
  - 테스트 컨텍스트에 Testcontainers 설정 빈을 추가 주입합니다.
  - DB 컨테이너가 뜨고, 데이터소스가 해당 컨테이너로 향하도록 만듭니다.
- `@TestPropertySource(locations = "classpath:application-test.properties")`
  - 테스트 전용 설정 파일을 활성화합니다(예: 로깅 레벨, Hibernate 설정 등).
  - 통합 테스트와 로컬 실행 설정을 분리해 안전하게 운영.

---

## 라이프사이클 훅: @BeforeEach, @AfterEach
- `@BeforeEach`
  - 각 테스트 메서드 시작 전 “공통 준비”를 수행합니다.
  - 예: 사용자/상품/옵션 초기 데이터 삽입, 기본 포인트 충전 등.
- `@AfterEach`
  - 테스트 후 “정리”를 수행합니다.
  - 예: 포인트 이력→사용자 순으로 삭제(외래키 제약 고려), 다음 테스트에 영향 없도록 클린업.
- 이렇게 하면 테스트 간 “데이터 간섭”이 없어 재현성이 좋아지고, 죄 없는 테스트가 실패하지 않습니다.

---

## 실제 테스트 코드 핵심 문법 살펴보기
### 1) PointConcurrencyTest (포인트 동시성)
- 핵심 코드: `ExecutorService` + `CountDownLatch`
  - 다중 스레드에서 `chargePoint`/`usePoint`를 동시에 호출하고, Latch로 모두 끝날 때까지 대기.
- 잔액 검증: `isEqualByComparingTo(BigDecimal)`
  - 50000 vs 50000.00 같은 스케일 차이를 무시하고 “수치 동등성”으로 비교.
- 왜 이렇게?
  - 진짜 동시 호출 상황을 흉내 내어, 락/트랜잭션이 제대로 작동하는지 검증.

### 2) StockConcurrencyTest (재고 동시성)
- 동시 예약: 다중 스레드로 `reserveStock` 호출 → 성공/실패 카운트를 `AtomicInteger`로 집계.
- 정책 정합성(이번 개선 핵심)
  - “예약 시 물리 재고 즉시 차감 → 확정은 상태만 변경 → 해제 시 복구(증가)”
  - 테스트는 이 정책을 가정하고 단정합니다(예: 50×2개 예약 후 재고 0, 확정 후에도 재고 80 유지 등).
- 왜 이렇게?
  - 예약합계 집계-후-차감 방식은 경쟁창이 커서 깨지기 쉽습니다. 즉시 차감은 경합을 단일 지점으로 모아 단순화합니다.

### 3) CouponConcurrencyTest (쿠폰 동시성)
- 선착순 한도/단일 발급 보장 검증.
- Testcontainers DB 위에서 실제 제약조건/인덱스 조건하에 동작을 확인.

---

## 이번에 개선한 사항
1) 비관적 락(PESSIMISTIC_WRITE) 도입
   - 사용자/상품옵션/예약 레코드를 갱신 전 잠그어 “직렬화”를 보장.
2) 재고 처리 정책 정합화
   - 예약 즉시 차감, 확정 시 중복 차감 금지, 해제 시 복구 → 테스트 정책과 코드 일치.
3) BigDecimal 비교 보정
   - 값은 동일하나 스케일이 달라 실패하던 단정을 수치 비교로 변경.
4) 테스트 정리/초기화 강화
   - `@BeforeEach`/`@AfterEach` 일관화로 테스트 간섭 제거.

---

## Testcontainers 실전 팁
- 컨테이너는 캐시/재사용 전략을 잘 쓰면 테스트 속도를 크게 줄일 수 있습니다.
- CI에서도 Docker만 있으면 “환경 같은 DB”를 즉시 띄울 수 있어 재현성이 뛰어납니다.
- 로컬 DB 직접 설치보다 안전하고, 인메모리 DB보다 현실적입니다.

---

## 결론
- 통합테스트는 “진짜에 가까운 환경에서 전체를 함께” 검증하는 마지막 방어선입니다.
- Testcontainers로 운영과 유사한 DB를 띄우고, 스프링 어노테이션/라이프사이클 훅으로 안정적인 테스트 바탕을 만들었습니다.
- 이번 개선으로 동시성 시나리오(포인트/재고), 쿠폰 선착순 정책이 기대대로 동작함을 확인했습니다.
